{
  "language": "Solidity",
  "sources": {
    "contracts/Controller.sol": {
      "content": "pragma solidity 0.8.7;\n\n/* solhint-disable indent */\n\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IMemberToken.sol\";\nimport \"./interfaces/IControllerRegistry.sol\";\nimport \"./SafeTeller.sol\";\nimport \"./ens/IPodENSRegistrar.sol\";\n\ncontract Controller is IController, SafeTeller {\n    event CreatePod(uint256 podId, address safe, address admin);\n    event UpdatePodAdmin(uint256 podId, address admin);\n\n    IMemberToken public immutable memberToken;\n    IControllerRegistry public immutable controllerRegistry;\n    IPodENSRegistrar public podENSRegistrar;\n\n    mapping(address => uint256) public safeToPodId;\n    mapping(uint256 => address) public podIdToSafe;\n    mapping(uint256 => address) public podAdmin;\n\n    uint8 internal constant CREATE_EVENT = 0x01;\n\n    /**\n     * @dev Will instantiate safe teller with gnosis master and proxy addresses\n     * @param _memberToken The address of the MemberToken contract\n     * @param _controllerRegistry The address of the ControllerRegistry contract\n     * @param _proxyFactoryAddress The proxy factory address\n     * @param _gnosisMasterAddress The gnosis master address\n     */\n    constructor(\n        address _memberToken,\n        address _controllerRegistry,\n        address _proxyFactoryAddress,\n        address _gnosisMasterAddress,\n        address _podENSRegisrar\n    ) SafeTeller(_proxyFactoryAddress, _gnosisMasterAddress) {\n        require(_memberToken != address(0), \"Invalid address\");\n        require(_controllerRegistry != address(0), \"Invalid address\");\n        require(_proxyFactoryAddress != address(0), \"Invalid address\");\n        require(_gnosisMasterAddress != address(0), \"Invalid address\");\n        require(_podENSRegisrar != address(0), \"Invalid address\");\n\n        memberToken = IMemberToken(_memberToken);\n        controllerRegistry = IControllerRegistry(_controllerRegistry);\n        podENSRegistrar = IPodENSRegistrar(_podENSRegisrar);\n    }\n\n    /**\n     * @param _members The addresses of the members of the pod\n     * @param threshold The number of members that are required to sign a transaction\n     * @param _admin The address of the pod admin\n     * @param _label label hash of pod name (i.e labelhash('mypod'))\n     * @param _ensString string of pod ens name (i.e.'mypod.pod.xyz')\n     */\n    function createPod(\n        address[] memory _members,\n        uint256 threshold,\n        address _admin,\n        bytes32 _label,\n        string memory _ensString\n    ) external {\n        address safe = createSafe(_members, threshold);\n\n        _createPod(_members, safe, _admin, _label, _ensString);\n    }\n\n    /**\n     * @dev Used to create a pod with an existing safe\n     * @dev Will automatically distribute membership NFTs to current safe members\n     * @param _admin The address of the pod admin\n     * @param _safe The address of existing safe\n     * @param _label label hash of pod name (i.e labelhash('mypod'))\n     * @param _ensString string of pod ens name (i.e.'mypod.pod.xyz')\n     */\n    function createPodWithSafe(\n        address _admin,\n        address _safe,\n        bytes32 _label,\n        string memory _ensString\n    ) external {\n        require(_safe != address(0), \"invalid safe address\");\n        require(safeToPodId[_safe] == 0, \"safe already in use\");\n        require(isSafeModuleEnabled(_safe), \"safe module must be enabled\");\n        require(\n            isSafeMember(_safe, msg.sender) || msg.sender == _safe,\n            \"caller must be safe or member\"\n        );\n\n        address[] memory members = getSafeMembers(_safe);\n\n        _createPod(members, _safe, _admin, _label, _ensString);\n    }\n\n    /**\n     * @param _members The addresses of the members of the pod\n     * @param _admin The address of the pod admin\n     * @param _safe The address of existing safe\n     * @param _label label hash of pod name (i.e labelhash('mypod'))\n     * @param _ensString string of pod ens name (i.e.'mypod.pod.xyz')\n     */\n    function _createPod(\n        address[] memory _members,\n        address _safe,\n        address _admin,\n        bytes32 _label,\n        string memory _ensString\n    ) private {\n        // add create event flag to token data\n        bytes memory data = new bytes(1);\n        data[0] = bytes1(uint8(CREATE_EVENT));\n\n        uint256 podId = memberToken.createPod(_members, data);\n\n        emit CreatePod(podId, _safe, _admin);\n        emit UpdatePodAdmin(podId, _admin);\n\n        if (_admin != address(0)) podAdmin[podId] = _admin;\n        podIdToSafe[podId] = _safe;\n        safeToPodId[_safe] = podId;\n\n        // setup pod ENS\n        address reverseRegistrar = podENSRegistrar.registerPod(_label, _safe);\n        setupSafeReverseResolver(_safe, reverseRegistrar, _ensString);\n    }\n\n    /**\n     * @param _podId The id number of the pod\n     * @param _newAdmin The address of the new pod admin\n     */\n    function updatePodAdmin(uint256 _podId, address _newAdmin) external {\n        address admin = podAdmin[_podId];\n        address safe = podIdToSafe[_podId];\n\n        require(safe != address(0), \"Pod doesn't exist\");\n\n        // if there is no admin it can only be added by safe\n        if (admin == address(0)) {\n            require(msg.sender == safe, \"Only safe can add new admin\");\n        } else {\n            require(msg.sender == admin, \"Only admin can update admin\");\n        }\n        podAdmin[_podId] = _newAdmin;\n\n        emit UpdatePodAdmin(_podId, _newAdmin);\n    }\n\n    /**\n     * @dev This will nullify all pod state on this controller\n     * @dev Update state on _newController\n     * @dev Update controller to _newController in Safe and MemberToken\n     * @param _podId The id number of the pod\n     * @param _newController The address of the new pod controller\n     * @param _prevModule The module that points to the orca module in the safe's ModuleManager linked list\n     */\n    function migratePodController(\n        uint256 _podId,\n        address _newController,\n        address _prevModule\n    ) external {\n        require(_newController != address(0), \"Invalid address\");\n        require(\n            controllerRegistry.isRegistered(_newController),\n            \"Controller not registered\"\n        );\n\n        address admin = podAdmin[_podId];\n        address safe = podIdToSafe[_podId];\n\n        require(\n            msg.sender == admin || msg.sender == safe,\n            \"User not authorized\"\n        );\n\n        Controller newController = Controller(_newController);\n\n        // nullify current pod state\n        podAdmin[_podId] = address(0);\n        podIdToSafe[_podId] = address(0);\n        safeToPodId[safe] = 0;\n        // update controller in MemberToken\n        memberToken.migrateMemberController(_podId, _newController);\n        // update safe module to _newController\n        migrateSafeTeller(safe, _newController, _prevModule);\n        // update pod state in _newController\n        newController.updatePodState(_podId, admin, safe);\n    }\n\n    /**\n     * @dev This is called by another version of controller to migrate a pod to this version\n     * @dev Will only accept calls from registered controllers\n     * @dev Can only be called once.\n     * @param _podId The id number of the pod\n     * @param _podAdmin The address of the pod admin\n     * @param _safeAddress The address of the safe\n     */\n    function updatePodState(\n        uint256 _podId,\n        address _podAdmin,\n        address _safeAddress\n    ) external {\n        require(_safeAddress != address(0), \"Invalid address\");\n        require(\n            controllerRegistry.isRegistered(msg.sender),\n            \"Controller not registered\"\n        );\n        require(\n            podAdmin[_podId] == address(0) &&\n                podIdToSafe[_podId] == address(0) &&\n                safeToPodId[_safeAddress] == 0,\n            \"Pod already exists\"\n        );\n        podAdmin[_podId] = _podAdmin;\n        podIdToSafe[_podId] = _safeAddress;\n        safeToPodId[_safeAddress] = _podId;\n\n        emit UpdatePodAdmin(_podId, _podAdmin);\n    }\n\n    /**\n     * @param operator The address that initiated the action\n     * @param from The address sending the membership token\n     * @param to The address recieveing the membership token\n     * @param ids An array of membership token ids to be transfered\n     * @param data Passes a flag for an initial creation event\n     */\n    function beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory,\n        bytes memory data\n    ) external override {\n        require(msg.sender == address(memberToken), \"Not Authorized\");\n\n        // if create event than side effects have been pre-handled\n        // only recognise data flags from this controller\n        if (operator == address(this) && uint8(data[0]) == CREATE_EVENT) return;\n\n        for (uint256 i = 0; i < ids.length; i += 1) {\n            uint256 podId = ids[i];\n            address safe = podIdToSafe[podId];\n            address admin = podAdmin[podId];\n\n            if (from == address(0)) {\n                // mint event\n\n                // there are no rules operator must be admin, safe or controller\n                require(\n                    operator == safe ||\n                        operator == admin ||\n                        operator == address(this),\n                    \"No Rules Set\"\n                );\n\n                onMint(to, safe);\n            } else if (to == address(0)) {\n                // burn event\n\n                // there are no rules  operator must be admin, safe or controller\n                require(\n                    operator == safe ||\n                        operator == admin ||\n                        operator == address(this),\n                    \"No Rules Set\"\n                );\n\n                onBurn(from, safe);\n            } else {\n                // transfer event\n                onTransfer(from, to, safe);\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IController.sol": {
      "content": "pragma solidity 0.8.7;\n\ninterface IController{\n\n    /**\n     * @param operator The account address that initiated the action\n     * @param from The account address sending the membership token\n     * @param to The account address recieving the membership token\n     * @param ids An array of membership token ids to be transfered\n     * @param amounts The amount of each membership token type to transfer\n     * @param data Arbitrary data\n     */\n    function beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) external;\n\n}\n"
    },
    "contracts/interfaces/IMemberToken.sol": {
      "content": "pragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\ninterface IMemberToken is IERC1155 {\n    /**\n     * @dev Total amount of tokens in with a given id.\n     */\n    function totalSupply(uint256 id) external view returns (uint256);\n\n    /**\n     * @dev Indicates weither any token exist with a given id, or not.\n     */\n    function exists(uint256 id) external view returns (bool);\n\n    function getNextAvailablePodId() external view returns (uint256);\n\n    /**\n     * @param _podId The pod id number \n     * @param _newController The address of the new controller\n     */\n    function migrateMemberController(uint256 _podId, address _newController)\n        external;\n\n    /**\n     * @param _account The account address to transfer the membership token to\n     * @param _id The membership token id to mint\n     * @param data Arbitrary data\n     */\n    function mint(\n        address _account,\n        uint256 _id,\n        bytes memory data\n    ) external;\n\n    /**\n     * @param _accounts The account addresses to transfer the membership tokens to\n     * @param _id The membership token id to mint\n     * @param data Arbitrary data\n     */\n    function mintSingleBatch(\n        address[] memory _accounts,\n        uint256 _id,\n        bytes memory data\n    ) external;\n\n    function createPod(address[] memory _accounts, bytes memory data) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/IControllerRegistry.sol": {
      "content": "pragma solidity 0.8.7;\n\n\ninterface IControllerRegistry{\n\n    /**\n     * @param _controller Address to check if registered as a controller\n     * @return Boolean representing if the address is a registered as a controller\n     */\n    function isRegistered(address _controller) external view returns (bool);\n\n}\n"
    },
    "contracts/SafeTeller.sol": {
      "content": "pragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./interfaces/IGnosisSafe.sol\";\nimport \"./interfaces/IGnosisSafeProxyFactory.sol\";\n\ncontract SafeTeller {\n    using Address for address;\n\n    // mainnet: 0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B;\n    address public immutable proxyFactoryAddress;\n\n    // mainnet: 0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F;\n    address public immutable gnosisMasterAddress;\n\n    string public constant FUNCTION_SIG_SETUP =\n        \"setup(address[],uint256,address,bytes,address,address,uint256,address)\";\n    string public constant FUNCTION_SIG_EXEC =\n        \"execTransaction(address,uint256,bytes,uint8,uint256,uint256,uint256,address,address,bytes)\";\n\n    string public constant FUNCTION_SIG_ENABLE = \"delegateSetup(address)\";\n\n    address internal constant SENTINEL = address(0x1);\n\n    /**\n     * @param _proxyFactoryAddress The proxy factory address\n     * @param _gnosisMasterAddress The gnosis master address\n     */\n    constructor(address _proxyFactoryAddress, address _gnosisMasterAddress) {\n        proxyFactoryAddress = _proxyFactoryAddress;\n        gnosisMasterAddress = _gnosisMasterAddress;\n    }\n\n    /**\n     * @param _safe The address of the safe\n     * @param _newSafeTeller The address of the new safe teller contract\n     */\n    function migrateSafeTeller(\n        address _safe,\n        address _newSafeTeller,\n        address _prevModule\n    ) internal {\n        // add new safeTeller\n        bytes memory enableData = abi.encodeWithSignature(\n            \"enableModule(address)\",\n            _newSafeTeller\n        );\n\n        bool enableSuccess = IGnosisSafe(_safe).execTransactionFromModule(\n            _safe,\n            0,\n            enableData,\n            IGnosisSafe.Operation.Call\n        );\n        require(enableSuccess, \"Migration failed on enable\");\n\n        // validate prevModule of current safe teller\n        (address[] memory moduleBuffer, ) = IGnosisSafe(_safe)\n            .getModulesPaginated(_prevModule, 1);\n        require(moduleBuffer[0] == address(this), \"incorrect prevModule\");\n\n        // disable current safeTeller\n        bytes memory disableData = abi.encodeWithSignature(\n            \"disableModule(address,address)\",\n            _prevModule,\n            address(this)\n        );\n\n        bool disableSuccess = IGnosisSafe(_safe).execTransactionFromModule(\n            _safe,\n            0,\n            disableData,\n            IGnosisSafe.Operation.Call\n        );\n        require(disableSuccess, \"Migration failed on disable\");\n    }\n\n    function getSafeMembers(address safe)\n        public\n        view\n        returns (address[] memory)\n    {\n        return IGnosisSafe(safe).getOwners();\n    }\n\n    function isSafeModuleEnabled(address safe) public view returns (bool) {\n        return IGnosisSafe(safe).isModuleEnabled(address(this));\n    }\n\n    function isSafeMember(address safe, address member)\n        public\n        view\n        returns (bool)\n    {\n        return IGnosisSafe(safe).isOwner(member);\n    }\n\n    /**\n     * @param _owners The  addresses to be owners of the safe\n     * @param _threshold The number of owners that are required to sign a transaciton\n     * @return safeAddress The address of the new safe\n     */\n    function createSafe(address[] memory _owners, uint256 _threshold)\n        internal\n        returns (address safeAddress)\n    {\n        bytes memory data = abi.encodeWithSignature(\n            FUNCTION_SIG_ENABLE,\n            address(this)\n        );\n\n        // encode the setup call that will be called on the new proxy safe\n        // from the proxy factory\n        bytes memory setupData = abi.encodeWithSignature(\n            FUNCTION_SIG_SETUP,\n            _owners,\n            _threshold,\n            this,\n            data,\n            address(0),\n            address(0),\n            uint256(0),\n            address(0)\n        );\n\n        try\n            IGnosisSafeProxyFactory(proxyFactoryAddress).createProxy(\n                gnosisMasterAddress,\n                setupData\n            )\n        returns (address newSafeAddress) {\n            return newSafeAddress;\n        } catch (bytes memory) {\n            revert(\"Create Proxy With Data Failed\");\n        }\n    }\n\n    /**\n     * @param to The account address to add as an owner\n     * @param safe The address of the safe\n     */\n    function onMint(address to, address safe) internal {\n        uint256 threshold = IGnosisSafe(safe).getThreshold();\n\n        bytes memory data = abi.encodeWithSignature(\n            \"addOwnerWithThreshold(address,uint256)\",\n            to,\n            threshold\n        );\n\n        bool success = IGnosisSafe(safe).execTransactionFromModule(\n            safe,\n            0,\n            data,\n            IGnosisSafe.Operation.Call\n        );\n\n        require(success, \"Module Transaction Failed\");\n    }\n\n    /**\n     * @param from The address to be removed as an owner\n     * @param safe The address of the safe\n     */\n    function onBurn(address from, address safe) internal {\n        uint256 threshold = IGnosisSafe(safe).getThreshold();\n        address[] memory owners = IGnosisSafe(safe).getOwners();\n\n        //look for the address pointing to address from\n        address prevFrom = address(0);\n        for (uint256 i = 0; i < owners.length; i++) {\n            if (owners[i] == from) {\n                if (i == 0) {\n                    prevFrom = SENTINEL;\n                } else {\n                    prevFrom = owners[i - 1];\n                }\n            }\n        }\n        if (owners.length - 1 < threshold) threshold -= 1;\n        bytes memory data = abi.encodeWithSignature(\n            \"removeOwner(address,address,uint256)\",\n            prevFrom,\n            from,\n            threshold\n        );\n\n        bool success = IGnosisSafe(safe).execTransactionFromModule(\n            safe,\n            0,\n            data,\n            IGnosisSafe.Operation.Call\n        );\n        require(success, \"Module Transaction Failed\");\n    }\n\n    /**\n     * @param from The address being removed as an owner\n     * @param to The address being added as an owner\n     * @param safe The address of the safe\n     */\n    function onTransfer(\n        address from,\n        address to,\n        address safe\n    ) internal {\n        address[] memory owners = IGnosisSafe(safe).getOwners();\n\n        //look for the address pointing to address from\n        address prevFrom;\n        for (uint256 i = 0; i < owners.length; i++) {\n            if (owners[i] == from) {\n                if (i == 0) {\n                    prevFrom = SENTINEL;\n                } else {\n                    prevFrom = owners[i - 1];\n                }\n            }\n        }\n\n        bytes memory data = abi.encodeWithSignature(\n            \"swapOwner(address,address,address)\",\n            prevFrom,\n            from,\n            to\n        );\n\n        bool success = IGnosisSafe(safe).execTransactionFromModule(\n            safe,\n            0,\n            data,\n            IGnosisSafe.Operation.Call\n        );\n        require(success, \"Module Transaction Failed\");\n    }\n\n\n    /**\n     * @dev This will execute a tx from the safe that will update the safe's ENS in the reverse resolver\n     * @param safe safe address\n     * @param reverseRegistrar The ENS default reverseRegistar \n     * @param _ensString string of pod ens name (i.e.'mypod.pod.xyz')\n     */\n    function setupSafeReverseResolver(\n        address safe,\n        address reverseRegistrar,\n        string memory _ensString\n    ) internal {\n        bytes memory data = abi.encodeWithSignature(\n            \"setName(string)\",\n            _ensString\n        );\n\n        bool success = IGnosisSafe(safe).execTransactionFromModule(\n            reverseRegistrar,\n            0,\n            data,\n            IGnosisSafe.Operation.Call\n        );\n        require(success, \"Module Transaction Failed\");\n    }\n\n    // TODO: move to library\n    // Used in a delegate call to enable module add on setup\n    function enableModule(address module) external {\n        require(module == address(0));\n    }\n\n    function delegateSetup(address _context) external {\n        this.enableModule(_context);\n    }\n}\n"
    },
    "contracts/ens/IPodENSRegistrar.sol": {
      "content": "pragma solidity 0.8.7;\n\ninterface IPodENSRegistrar { \n\n    function registerPod(bytes32 label, address podSafe) external returns (address);\n\n    function register(bytes32 label, address owner) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IGnosisSafe.sol": {
      "content": "pragma solidity 0.8.7;\n\ninterface IGnosisSafe {\n\n    enum Operation {Call, DelegateCall}\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Operation operation\n    ) external returns (bool success);\n\n    /// @dev Returns array of owners.\n    /// @return Array of Safe owners.\n    function getOwners() external view returns (address[] memory);\n\n    function isOwner(address owner) external view returns (bool);\n\n    function getThreshold() external returns (uint256);\n\n    /// @dev Returns array of modules.\n    /// @param start Start of the page.\n    /// @param pageSize Maximum number of modules that should be returned.\n    /// @return array Array of modules.\n    /// @return next Start of the next page.\n    function getModulesPaginated(address start, uint256 pageSize)\n        external \n        view\n        returns (address[] memory array, address next);\n\n    /// @dev Returns if an module is enabled\n    /// @return True if the module is enabled\n    function isModuleEnabled(address module) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IGnosisSafeProxyFactory.sol": {
      "content": "pragma solidity 0.8.7;\n\ninterface IGnosisSafeProxyFactory {\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\n    /// @param singleton Address of singleton contract.\n    /// @param data Payload for message call sent to new proxy contract.\n    function createProxy(address singleton, bytes memory data)\n        external\n        returns (address);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}